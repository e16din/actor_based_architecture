Начало
-------

Привет, меня зовут Александр и я разрабатываю Android-приложения. 

На моем счету около 50-ти разного рода приложений, и по типу, назначению и по размеру.

У меня есть мечта - сделать разработку мобильных приложений простой и убрать оверхед из своих проектов.

История
-------

Я тут хотел обойти острые углы и сосредоточиться на позитиве, но как-то все получается слишком ванильным, добавлю щепотку гнева.

Меня задолбало что для написания простого приложения надо писать горы оторванных от реальности абстракций. Меня задолбало что чем больше становится проект тем сложнее разбираться в его коде. Меня задолбало что я долго разбираюсь с кодом других разработчиков, а другие разработчики долго разбираются с моим кодом. Меня задолбало что подходы призванные упростить работу с кодом, усложняют структуру этого кода. Меня задолбало что проект собирается по 5-10 минут. Меня задолбало.. можем продолжить список в комментариях ;)

Я перепробовал много всякого чтобы поменять процесс разработки к лучшему и в итоге я замахнулся на святое - я решил придумать такую архитектуру, которая бы была проста в реализации, очевидно-понятна без лишних объяснений, легко масштабировалась на любого размера проект. И да, чтобы не надо было для этой архитектуры делать громоздкий фреймворк.

Как-то раз с моей женой(она как раз училась на философском; любимая, спасибо) мы завели разговор про объективирование и субъект-субъектные отношения, и тут меня осенило!

А что если описать бизнес процессы не упрощенно и утилитарно, как мы привыкли делать, пишем все с позиции приложения, в лучшем случае с позиции приложения и пользователя, что если полностью описать все субъекты участвующие в бизнес-процессе?

Я переложил философские идеи субъект-субъектного взаимодействия на архитектуру мобильного приложения и получил способ моделирования наиболее полного бизнесс-процесса, на основе моделирования действующих субъектов на каждом экране приложения. 

В последствии я выяснил что у термина "субъект" в разных областях свое значение и это несет некоторую путаницу в смыслах. Я буду говорить о субъектах как о действующих лицах учавствующих в процессе. Или даже давайте сразу использовать термин "действующее лицо", актор.

Решение
-------

В процессе использования приложения есть ряд действующих лиц, акторов.
Само приложение - это актор. Экран приложения - это актор. Пользователь который взаимодействует с экраном приложения - это актор. Сервер - это актор. Операционная система телефона - это актор. 

Наличие этих всех действующих лиц характерно для большинства мобильных приложений (в некоторых приложениях бывает несколько типов пользователей - например заказчик и исполнитель - это разные акторы). Разные акторы, кстати, дают исполнение принципа Single Responsibility из коробки, без лишних заморочек.

Раньше большинство действующих лиц были за кадром, где-то там в головах разработчиков, менеджеров и бизнеса, а теперь мы моделируем бизнесс-процесс явно описывая взаимодействие всех акторов.

Каждый экран по сути это актор. Он может взаимодействовать с пользователем который тоже актор - например экран показывает пользователю сообщение об ошибке, а пользователь жмет на кнопку "ок". Так же экран может взаимодействовать с сервером - отправить данные, получить данные. Еще он может взаимодействовать с операционной системой телефона - скрыть системную клавиатуру, получить сообщение о сворачивании приложения. Один экран может взаимодействовать с другим экраном - например передавать или получать данные. Само приложение это тоже актор, и любые экраны-акторы могут например сохранять/получать данные из приложения, или подписаться на какое-то глобальное событие - например изменение настроек приложения.

На такой акторный подход моделирования очень хорошо ложится теория систем, по сути мы явно описываем механизм взаимодействия систем которые учавствуют в работе приложения.

Пример
------

Посмотрим на схему взаимодействия акторов на примере приложения такси:

![taxi_main_screen](taxi_main_screen.svg)

Так как сущность актора неделима и объемна, а создавать God-объект под каждое действующее лицо так себе затея, я использую понятие "действующее лицо" для проектирования и объяснения, а в коде я использую понятие "агент" - своеобразный абстрактный интерфейс к реальному актору.

Актор един - агентов этого актора может быть сколько угодно в рамках приложения.

Давайте посмотрим на пример кода экрана приложения такси:

```kotlin
class MainFragment : Fragment(), Screen {

    inner class AppAgent {
        private val gson = Gson()

        var isAuthorized: Boolean = false
            // ...

        var lastLocation: Location? = null
            // ...

        // ...
    }

    inner class UserAgent {
        fun lookAtMap(location: Location) {
            // ...
        }

        fun lookAtActionsBottomSheet() {
            // ...
        }

        fun lookAtBonusesCount(bonusesCount: Int) {
            // ...
        }

        fun lookAtSideBar(sidebarOpened: Boolean) {
            // ...
        }

        fun lookAtLocationDoNotAvailableMessage() {
            // ...
        }
    }

    inner class ServerAgent {
        suspend fun getBonusesCount(): Int? {
           // ...
        }
    }

    inner class SystemAgent {
        var lastLocation: Location? = null

        fun trackLocation() {
            // ...
        }
    }

    @Parcelize
    class MainScreenData(
        var bonusesCount: Int = 0,
        var isSideBarOpened: Boolean = false
    ) : Parcelable

    private val appAgent = AppAgent()
    private val userAgent = UserAgent()
    private val systemAgent = SystemAgent()
    private val serverAgent = ServerAgent()

    // ...

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        systemAgent.trackLocation()

        binding = FragmentMainBinding.inflate(inflater)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        savedInstanceState?.getParcelable<MainScreenData>(screenDataKey)?.let {
            screenData = it
        }

        val lastLocation = systemAgent.lastLocation
            ?: appAgent.lastLocation
        lastLocation?.let {
            userAgent.lookAtMap(lastLocation)
        } ?: run {
            userAgent.lookAtLocationDoNotAvailableMessage()
        }

        userAgent.lookAtActionsBottomSheet()
        userAgent.lookAtSideBar(screenData.isSideBarOpened)

        lifecycleScope.launch {
            screenData.bonusesCount = serverAgent.getBonusesCount()
                ?: screenData.bonusesCount
            userAgent.lookAtBonusesCount(screenData.bonusesCount)
        }
    }
    
    // ...
}
```

Обратите внимание что основная бизнес-логика находится в блоке onViewCreated(), а реализация в классах агентов.

В каждом классе агенте содержатся публичные функции, и каждая из них является своего рода интерактором, юзкейсом. 

Если присмотреться то получается довольно чистая архитектура :)


Весь код примера можете посмотреть [здесь](https://github.com/e16din/mobile_subject_oriented_programming/blob/main/example/app/src/main/java/com/e16din/mytaxi/screens/main/MainFragment.kt).

Плюсы
------

В итоге мне удалось задуманное - я нашел способ строить архитектуру приложения без использования различных MV*-подходов и Android Clean Architecture, просто и понятно, описывая реальные сущности и реальные действия (вместо выдуманных схем и слоев). И это не God-объекты, не Massive что-то там, это отлично структурированные системы в которых просто ориентироваться. 

Чтобы как-то называть новый подход, я придумал название - акторная архитектура, или Actor Based-Architecture.

Этот подход дает ряд преимуществ: 
- абстракции акторов в коде хорошо понятны любому человеку, так как они описывают реальные сущности - экран, приложение, пользователь, сервер, телефон;
- логика текущего экрана приложения содержится в одном месте и не размазана по разным файлам и слоям (для сложных экранов можно применить композицию);
- порог входа в проект для разработчиков снижается, да и самому в своем старом коде проще ориентироваться;
- надо писать меньше кода, разработка ускоряется;
- код хорошо структурирован, такой код легко писать и легко читать;
- не надо выдумывать много пакетов и решать что где должно храниться;
- классы платформы остаются классами платформы, и живут по своим законам, мы не нагружаем их дополнительными смыслами, что убирает путаницу;
- на выходе имеем чистую архитектуру без оверхеда по классам и без лишнего мэпинга моделей;
- Single Responsibility из коробки;
- не требуется гонять данные из класса в класс, а значит отпадает необходимость в дополнительных инструмментах для этого, типа LiveData/Rx/Flow (их можно использовать для чего-то более специфичного);
- эту архитектуру можно переносить из проекта в проект без каких-то фреймворков;

Минусы которые я вижу:
- код реализации интеракторов зависит от платформы (зато можно переносить всю логику практически без изменений); это в принципе решаемо если разделить на интерфейс и реализацию;
- подход не привычный, отличается от всего того что мы привыкли использовать в проде; надо набивать руку и нарабатывать опыт с нуля;

Заключение
------------

Хоть начал я с негатива, в конце закончу позитивом :)

Хочу выразить огромную признательность всем тем людям кто писал статьи, книги, выпускал подкасты, снимал видео на ютубе, всем тем людям кто генерировал полезную информацию по программированию и разработке. Отдельное спасибо всем тем кто писал библиотеки, сервисы, и тестовые примеры к ним. Еще спасибо всем тем кто создавал операционные системы, и поддерживает их сейчас. И конечно спасибо всем тем людям с чьим кодом мне пришлось столкнуться по работе. Весь мой опыт построен из взаимодействия с вашим творчеством. А так же спасибо вашим близким что помогают вам заниматься этими полезными делами. И конечно же спасибо моим близким :)

Я в программировании давно, и знаю что моя благодарность запоздала, она возникла сейчас и пользуясь этой возможностью я еще раз говорю вам - спасибо!

P.S.:
===

Буду рад если этот подход сделает процесс разработки более простым и удобным для всех нас :)

Призываю посмотреть на тестовый проект и поэкспериментировать с этим подходом, если понравится - используйте и распространяйте.

Вопросы, предложени и любую другую обратную связь - пишите в коментариях или в issues к репозиторию.
