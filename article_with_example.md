Начало
-------

Привет, меня зовут Александр и я разрабатываю Android-приложения. 

На моем счету около 50-ти разного рода приложений, и по типу, назначению и по размеру.

У меня есть мечта - сделать разработку мобильных приложений простой и убрать оверхед из своих проектов.

История
-------

Я тут хотел обойти острые углы и сосредоточиться на позитиве, но как-то все получается слишком ванильным, добавлю щепотку гнева.

Меня задолбало что для написания простого приложения надо писать горы оторванных от реальности абстракций. Меня задолбало что чем больше становится проект тем сложнее разбираться в его коде. Меня задолбало что я долго разбираюсь с кодом других разработчиков, а другие разработчики долго разбираются с моим кодом. Меня задолбало что подходы призванные упростить работу с кодом, усложняют структуру этого кода. Меня задолбало что проект собирается по 5-10 минут. Меня задолбало.. можем продолжить список в комментариях ;)

Я перепробовал много всякого чтобы поменять процесс разработки к лучшему и в итоге я замахнулся на святое - я решил придумать такую архитектуру, которая бы была проста в реализации, очевидно-понятна без лишних объяснений, легко масштабировалась на любого размера проект. И да, чтобы не надо было для этой архитектуры делать громоздкий фреймворк.

Как-то раз с моей женой(она как раз училась на философском; любимая, спасибо) мы завели разговор про объективирование и субъект-субъектные отношения, и тут меня осенило!

А что если описать бизнес процессы не упрощенно и утилитарно, как мы привыкли делать, пишем все с позиции приложения, в лучшем случае с позиции приложения и пользователя, что если полностью описать все субъекты участвующие в бизнес-процессе?

Я переложил философские идеи субъект-субъектного взаимодействия на архитектуру мобильного приложения и получил способ моделирования наиболее полного бизнесс-процесса, на основе моделирования действующих субъектов на каждом экране приложения. 

В последствии я выяснил что у термина "субъект" в разных областях свое значение и это несет некоторую путаницу в смыслах. Я буду говорить о субъектах как о действующих лицах учавствующих в процессе. Или даже давайте сразу использовать термин "действующее лицо" - актор.

Решение
-------

В процессе использования приложения есть ряд действующих лиц, акторов.
Само приложение - это актор. Экран приложения - это актор. Пользователь который взаимодействует с экраном приложения - это актор. Сервер - это актор. Операционная система телефона - это актор. 

Наличие этих всех действующих лиц характерно для большинства мобильных приложений (в некоторых приложениях бывает несколько типов пользователей - например заказчик и исполнитель - это разные акторы). Разные акторы, кстати, дают исполнение принципа Single Responsibility из коробки, без лишних заморочек.

Раньше большинство действующих лиц были за кадром, где-то там в головах разработчиков, менеджеров и бизнеса, а теперь мы моделируем бизнесс-процесс явно описывая взаимодействие всех акторов.

Каждый экран по сути это актор. Он может взаимодействовать с пользователем который тоже актор - например экран показывает пользователю сообщение об ошибке, а пользователь жмет на кнопку "ок". Так же экран может взаимодействовать с сервером - отправить данные, получить данные. Еще он может взаимодействовать с операционной системой телефона - скрыть системную клавиатуру, получить сообщение о сворачивании приложения. Один экран может взаимодействовать с другим экраном - например передавать или получать данные. Само приложение это тоже актор, и любые экраны-акторы могут например сохранять/получать данные из приложения, или подписаться на какое-то глобальное событие - например изменение настроек приложения.

На такой акторный подход моделирования очень хорошо ложится теория систем, по сути мы явно описываем механизм взаимодействия систем которые учавствуют в работе приложения.

Пример
------

Посмотрим на схему взаимодействия акторов на примере приложения такси:

![taxi_main_screen](taxi_main_screen.svg)


Сущность каждого актора неделима и объемна, а создавать God-объект под каждое действующее лицо так себе затея, поэтому я не описываю акторы напрямую в коде.

Вместо этого я создаю "агентов" - это такие интерфейсы через которые мы общаемся с реальными сущностями-акторами(пользователем, сервером, экраном и т.д.).

Грубо говоря в каждом фрагменте(активити) существует свой набор агентов, эти агенты имплементируют только необходимый функционал для взаимодействия акторов на этом фрагменте.

Давайте посмотрим на пример кода экрана приложения такси: 

(//todo: похоже надо написать что-то более легковесное, чтобы акцентировать внимание на концепции, а не на логике приложения)

```kotlin
class MainFragment : Fragment(), DataKey {

    // NOTE: агент для актора работающего приожения
    inner class AppAgent {
        // ...
    }

    @Serializable
    class MainScreenData(
        var bonusesCount: Int = 0,
        var isSideBarOpened: Boolean = false,
        var selectedRoute: Route = Route(),
        var lastPlaces: List<Place> = emptyList(),
        var services: List<Service> = emptyList(),
        var selectedService: Service? = null,
        var screenState: ScreenState = ScreenState.ToSelectRoute,
        var orderedCar: OrderResult.Car? = null
    ) : java.io.Serializable {

        enum class ScreenState {
            ToSelectRoute,
            ToOrderService,
            ToSearchCar, //todo: InProgress, Success, Fail
            ToWaitForCar, //todo: Await, Done, Canceled
            ToTrackTrip, //todo: Await, Done, Canceled
            ToRateService //todo: add rate screen
        }
    }

    // NOTE: агент для актора главного экрана
    inner class MainScreenAgent {
        lateinit var data: MainScreenData
    }

    // NOTE: агент для актора экрана выбора маршрута
    inner class SelectRouteScreenAgent {
        // ...
    }

    // NOTE: агент для актора пользователя
    inner class UserAgent {
        // ...
    }

    // NOTE: агент для актора сервера
    inner class ServerAgent {
        // ...
    }

    // NOTE: агент для актора операционной системы телефона
    inner class SystemAgent {
        // ...
    }

    private val appAgent = AppAgent()
    private val screenAgent = MainScreenAgent()
    private val selectRouteScreenAgent = SelectRouteScreenAgent()
    private val userAgent = UserAgent()
    private val systemAgent = SystemAgent()
    private val serverAgent = ServerAgent()

    private lateinit var binding: FragmentMainBinding


    init {
        systemAgent.onCreateView = {
            systemAgent.trackLocation { location ->
                appAgent.lastLocation = location
            }
        }

        systemAgent.onViewCreated = { savedInstanceState ->
            screenAgent.data = systemAgent.restoreData(savedInstanceState)
                ?: MainScreenData()

            when (screenAgent.data.screenState) {
                MainScreenData.ScreenState.ToSelectRoute -> {
                    switchToSelectRouteState()
                }
                MainScreenData.ScreenState.ToOrderService -> {
                    switchToOrderServiceState(screenAgent.data.selectedRoute)
                }
                MainScreenData.ScreenState.ToSearchCar -> {
                    screenAgent.data.selectedService?.let {
                        switchToSearchCarState(it)
                    }
                }
                MainScreenData.ScreenState.ToWaitForCar -> {
                    switchToWaitForCarState()
                }
                MainScreenData.ScreenState.ToTrackTrip -> {
                    // todo:
                }
                MainScreenData.ScreenState.ToRateService -> {
                    // todo:
                }
            }

            userAgent.lookAtLeftSideBar(
                sidebarOpened = screenAgent.data.isSideBarOpened,
                onSideBarStateChanged = { opened ->
                    screenAgent.data.isSideBarOpened = opened
                }
            )

            lifecycleScope.launch {
                val lastPlaces = serverAgent.getLastPlaces(2)
                    ?: screenAgent.data.lastPlaces

                fun onLastPlaceClick(position: Int) {
                    screenAgent.data.selectedRoute.finishPlace = lastPlaces[position]
                    switchToOrderServiceState(screenAgent.data.selectedRoute)
                }

                userAgent.lookAtLastPlacesList(
                    lastPlaces = lastPlaces,
                    onLastPlace1Click = { onLastPlaceClick(0) },
                    onLastPlace2Click = { onLastPlaceClick(1) }
                )

                screenAgent.data.bonusesCount = serverAgent.getBonusesCount()
                    ?: screenAgent.data.bonusesCount
                userAgent.lookAtBonusesCount(screenAgent.data.bonusesCount)
            }

            systemAgent.onSaveInstanceState = { outState ->
                systemAgent.saveData(outState)
            }
        }
    }

    // ...

    private fun switchToOrderServiceState(route: Route) {
        screenAgent.data.screenState = MainScreenData.ScreenState.ToOrderService
        userAgent.lookAtRouteLine(screenAgent.data.selectedRoute)
        userAgent.lookAtOrderArea()
        userAgent.lookAtOrderRouteFields(route)

        lifecycleScope.launch {
            screenAgent.data.services = serverAgent.getServices()
            userAgent.lookAtServices(screenAgent.data.services)
            userAgent.lookAtOrderButton(
                service = screenAgent.data.selectedService,
                onOrderClick = { service ->
                    switchToSearchCarState(service)
                }
            )
        }
    }

    // ...
}
```

Обратите внимание что вся логика находится в блоке init {}, а реализация в классах агентов.

В каждом классе агенте содержатся публичные функции и каждая из них является своего рода интерактором/юзкейсом. 

Если присмотреться то получается довольно чистая архитектура :)


Весь код примера можете посмотреть [здесь](https://github.com/e16din/mobile_subject_oriented_programming/blob/main/example/app/src/main/java/com/e16din/mytaxi/screens/main/MainFragment.kt).

Плюсы
------

В итоге мне удалось задуманное - я нашел способ строить архитектуру приложения без использования различных MV*-подходов и Android Clean Architecture, просто и понятно, описывая реальные сущности и реальные действия (вместо выдуманных схем и слоев). И это не God-объекты, не Massive что-то там, это отлично структурированные системы в которых просто ориентироваться. 

Чтобы как-то называть новый подход, я придумал название - акторная архитектура, или Actor Based-Architecture.

Этот подход дает ряд преимуществ: 
- агенты акторов в коде хорошо понятны любому человеку, так как они описывают реальные сущности - экран, приложение, пользователь, сервер, телефон;
- логика текущего экрана приложения содержится в одном месте и не размазана по разным файлам и слоям (для сложных экранов можно применить композицию);
- порог входа в проект для разработчиков снижается, да и самому в своем старом коде проще ориентироваться;
- надо писать меньше кода, разработка ускоряется;
- код хорошо структурирован, такой код легко писать и легко читать;
- не надо выдумывать много пакетов и решать что где должно храниться;
- классы платформы остаются классами платформы, и живут по своим законам, мы не нагружаем их дополнительными смыслами, что убирает путаницу;
- на выходе имеем чистую архитектуру без оверхеда по классам и без лишнего мэпинга моделей;
- Single Responsibility из коробки со всеми его плюсами;
- не требуется гонять данные из класса в класс, а значит отпадает необходимость в дополнительных инструмментах для этого, типа LiveData/Rx/Flow (их можно использовать для чего-то более специфичного);
- эту архитектуру можно переносить из проекта в проект без каких-то фреймворков;
- логику взаимодействия акторов свободно можно шарить между платформами (останется только подставить реализацию);

Минусы которые я вижу:
- подход не привычный, отличается от всего того что мы привыкли использовать в проде; 
- надо набивать руку и нарабатывать опыт с нуля; (что по своему приятно :)

Заключение
------------

Хоть начал я с негатива, в конце закончу позитивом :)

Хочу выразить огромную признательность всем тем людям кто писал статьи, книги, выпускал подкасты, снимал видео на ютубе, всем тем людям кто генерировал полезную информацию по программированию и разработке и около всего этого. Спасибо людям которые задают вопросы и отвечают на stackoverflow. Отдельное спасибо всем тем кто писал библиотеки, сервисы, и тестовые примеры к ним. Еще спасибо всем тем кто создавал операционные системы, и поддерживает их сейчас. И конечно спасибо всем тем людям с чьим кодом мне пришлось столкнуться по работе. Весь мой опыт построен из взаимодействия с вашим творчеством. А так же спасибо вашим близким что помогают вам заниматься этими полезными делами. И конечно же спасибо моим близким :)

Я в программировании давно, и знаю что моя благодарность запоздала, она возникла сейчас и пользуясь этой возможностью я еще раз говорю вам - спасибо!

P.S.:
===

Буду рад если этот подход сделает процесс разработки более простым и удобным для всех нас :)

Призываю посмотреть на тестовый проект и поэкспериментировать с этим подходом, если понравится - используйте и распространяйте.

Вопросы, предложения и любую другую обратную связь - пишите в коментариях или в issues к репозиторию.
